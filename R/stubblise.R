#' Create simple synthetic data from a data frame-like objects
#'
#' `stubblise()` (equivalently, `stubblize()`) generates synthetic (i.e.
#' simulated) data to match the structure of a given data frame-like object
#' (including data.frames, tibbles, data.tables, and lists). See also
#' [gen_col], which does the work, and [control] for information on
#' user-modifiable parameters.
#'
#' @param x the data frame-like object to emulate. Can have 0 rows.
#' @param rows the number of rows to generate.
#' @param control a named list of control parameters for generating the
#' synthetic data. See [control].
#' @param ... named individual control parameters, which take precedence over
#' those in the `control` list.
#'
#' @details One intended use of `stubblise()` is in generating test data for R
#' package development. The function can create very simple synthetic data from
#' most data frame-like objects where columns have base R vector types. Lists
#' of vectors of unequal lengths (i.e. not coerceable to `data.frame`) are
#' allowed. Currently list-columns are not fully supported, and this and any
#' other unsupported types will return a column of `NA`s (for unsupported
#' types, the resulting column of `NA`s will have type `numeric`).
#'
#' Data are randomly generated by sampling uniformly from a numeric or integer
#' range or from a selection of e.g. characters or factor levels. The
#' parameters controlling this sampling can be modified by the user. Control
#' parameters can be lists, in which case elements are matched (with recycling)
#' to corresponding columns.
#'
#' Note that although `x` can have 0 rows, there is no benefit to passing
#' `stubblise()` an object with 0 rows. The computation time is not dependent on
#' the number of rows in `x` (thanks to the magic of S3 methods and lazy
#' evaluation).  Computation time does increase, approximately linearly, with
#' the number of columns in `x` and with the number of rows required in the
#' result (`rows`).
#'
#' The function `stubblize()` is a synonym for `stubblise()`.
#'
#' @return A data frame-like object with the same class as `x` (unless `x` is a
#' `list` or otherwise is coerceable to a `data.frame`, in which case the
#' result is a `data.frame`). Any columns which are not recognised as being of
#' a standard vector type will have `NA` for all rows and the column type will
#' be `numeric`, i.e. not the original vector type.
#'
#' @section Sensitive data:
#'
#' By default, outputs from `stubblise()` should contain no sensitive data,
#' **unless the column names and types are themselves sensitive**. Attributes of
#' `x` are not preserved by `stubblise()` by default, and any attributes that
#' persist will have been regenerated by coercion (e.g. by `as.data.frame()`)
#' and are therefore unlikely to be sensitive information.
#'
#' It is possible to leak sensitive data via a "stubblised" data frame if the
#' values of the [control] parameters are themselves derived from sensitive
#' data. It is recommended to leave these parameters at their default values in
#' any circumstance that involves sensitive data (e.g. personal data of any
#' sort), or otherwise to ensure that they are set to non-informative and/or
#' non-sensitive values.
#'
#' @examples
#' # A simple examples producing nonsense data
#' syn_iris_0 <- stubblise(iris)
#'
#' # Example with Species factor levels
#' syn_iris_1 <- stubblise(
#'   iris,
#'   fct_lvls = list(levels(iris$Species))
#' )
#'
#' # Example producing data more comparable to the real iris
#' mins <- as.numeric(dplyr::summarise_if(iris, is.numeric, min))
#' maxs <- as.numeric(dplyr::summarise_if(iris, is.numeric, max))
#' lvls <- levels(iris$Species)
#' rows <- dplyr::count(iris, Species)$n
#' syn_iris_2 <- purrr::map2_dfr(
#'   rows, lvls,
#'   ~ stubblise(
#'     iris, rows = .x,
#'     control = list(
#'       dbl_min = mins, dbl_max = maxs, dbl_round = 1L,
#'       fct_lvls = list(lvls), fct_use_lvls = list(.y)
#'     )
#'   )
#' )
#' 
#' @export
stubblise <- function(x, ...) {
  UseMethod("stubblise", x)
}


# US spelling
#' @rdname stubblise
#' @export
stubblize <- stubblise


# Default
#' @rdname stubblise
#' @export
stubblise.default <- function(x, rows = 10L, control = list(), ...) {

  tryCatch(
    x <- as.list(x),
    error = function(err) stop("Cannot coerce argument 'x' to data.frame"),
    warning = function(warn) warning(warn)
  )

  as.data.frame(stbls_(x, rows, control, ...))

}


# Data frames
#' @rdname stubblise
#' @export
stubblise.data.frame <- function(x, rows = 10L, control = list(), ...) {
  as.data.frame(stbls_(x, rows, control, ...))
}


# Tibbles
#' @rdname stubblise
#' @export
stubblise.tbl_df <- function(x, rows = 10L, control = list(), ...) {
  tibble::as_tibble(stbls_(x, rows, control, ...))

}


# Data tables
#' @rdname stubblise
#' @export
stubblise.data.table <- function(x, rows = 10L, control = list(), ...) {
  data.table::as.data.table(stbls_(x, rows, control, ...))
}


# Lists
#' @rdname stubblise
#' @export
stubblise.list <- function(x, rows = 10L, control = list(), ...) {
  as.data.frame(stbls_(x, rows, control, ...))
}


# Internals
stbls_ <- function(x, rows = 10L, control = list(), ...) {
  if (!is.list(control)) stop("Argument `control` must be a list")
  index <- 1:length(x)
  mapply(
    gen_col, col = x, index = index,
    MoreArgs = list(elements = rows, control = control, ...),
    SIMPLIFY = FALSE,
    USE.NAMES = TRUE
  )
}
