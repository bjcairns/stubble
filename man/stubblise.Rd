% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stubble.R, R/stubblise.R
\name{stubble}
\alias{stubble}
\alias{stubblise}
\alias{stubblize}
\title{Create simple simulated data from a tibble}
\usage{
stubblise(x, ...)

stubblize(x, ...)
}
\arguments{
\item{x}{the data frame-like object to emulate. Can have 0 rows.}

\item{...}{control parameters for ranges and valid levels/characters in the
synthetic data. See \link{control}.}

\item{rows}{the number of simulated rows to generate.}
}
\value{
A data frame-like object with the same class as \code{x} (unless \code{x} is a
\code{list} or otherwise is coerceable to a \code{data.frame}, in which case the
result is a \code{data.frame}). Any columns which are not recognised as being of
a standard vector type will have \code{NA} for all rows and the column type will
be \code{numeric}, i.e. not the original vector type.
}
\description{
\code{stubblise()} (equivalently, \code{stubblize()}) generates synthetic (i.e.
simulated) data to match the structure of a given data frame-like object
(including data.frames, tibbles, data.tables, and lists). See also
\link{gen_col}, which does the work, and \link{control} for information on
user-modifiable parameters.
}
\details{
One intended use of \code{stubblise()} is in generating test data for R
package development. The function can create very simple synthetic data from
most data frame-like objects where columns have base R vector types. Lists
of vectors of unequal lengths (i.e. not coerceable to \code{data.frame}) are
allowed. Currently list-columns are not fully supported, and this and any
other unsupported types will return a column of \code{NA}s (for unsupported
types, the resulting column of \code{NA}s will have type \code{numeric}).

Data are randomly generated by sampling uniformly from a numeric or integer
range or from a selection of e.g. characters or factor levels. The
parameters controlling this sampling can be modified by the user. Control
parameters can be lists, in which case elements are matched (with recycling)
to corresponding columns.

Note that although \code{x} can have 0 rows, there is no benefit to passing
\code{stubblise()} an empty tibble. The computation time is not dependent on
the number of rows in \code{x} (thanks to the magic of S3 methods and lazy
evaluation).  Computation time does increase, approximately linearly, with
the number of columns in \code{x} and with the number of rows required in the
result (\code{rows}).

The function \code{stubblize()} is a synonym for \code{stubblise()}.
}
\section{Sensitive data}{


By default, outputs from \code{stubblise()} should contain no sensitive data,
\emph{unless the column names and types are themselves sensitive}. Attributes of
\code{x} are not preserved by \code{stubblise()}, although some may be regenerated by
coercive \code{as.} functions (in which case they are not sensitive).

It is possible to leak sensitive data via a "stubblised" data frame if the
values of the \link{control} parameters are themselves derived from sensitive
data. It is recommended to leave these parameters at their default values in
any circumstance that involves sensitive data (e.g. personal data of any
sort), or otherwise to ensure that they are set to non-informative values.
}

\examples{
# A simple examples producing nonsense data
syn_iris_0 <- stubblise(iris)

# Example with Species factor levels
syn_iris_1 <- stubblise(
  iris,
  fct_lvls = list(levels(iris$Species))
)

# Example producing data more comparable to the real iris
mins <- as.numeric(dplyr::summarise_if(iris, is.numeric, min))
maxs <- as.numeric(dplyr::summarise_if(iris, is.numeric, max))
lvls <- levels(iris$Species)
rows <- dplyr::count(iris, Species)$n
syn_iris_2 <- purrr::map2_dfr(
  rows, lvls,
  ~ stubblise(
    iris, rows = .x,
    dbl_min = mins, dbl_max = maxs, dbl_round = 1L,
    fct_lvls = list(lvls), fct_use_lvls = list(.y)
  )
)

}
