---
title: "Using stubblise()"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using stubble}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**stubble** helps you generate simple synthetic datasets matching the format of a supplied data frame-like object (including base R data frames, tibbles, data.tables, and lists of vectors). 

The most basic usage of stubble employs `stubblise()` (or, `stubblize()`) to return a synthetic dataset based on the original data provided to the function.

Examples on this page use the `penguins_ext` dataset, which includes measurements of physical characteristics and information on nesting success of penguins of several species on islands in the Palmer Archipelago. These data are derived from the [palmerpenguins](https://github.com/allisonhorst/palmerpenguins) package. For the purpose of these examples, we'll use a slightly cut-down version of the dataset:

```{r usedata}
library(stubble)
p <- penguins_ext[, c(
       "id", 
       "species", 
       "bill_length_mm", 
       "body_mass_g", 
       "clutch_completion", 
       "date_egg"
     )]
head(p)
```

## Default operation: `method = "agnostic"`

Because real data are often sensitive and unsuitable for sharing, stubble produces nonsense data unless you tell it not to. With default options, the function `stubblise()` (equivalently, `stubblize()`) will produce a data frame that shares only the column names and types with the source dataset.

Let's generate a "stubblised" (i.e. synthetic) dataset with 100 rows:

``` {r seed, echo=FALSE}
use_seed <- 98723895
set.seed(use_seed)
```

```{r example}
library(stubble)
use_seed <- 98723895
set.seed(use_seed)
p_agn <- stubblise(p, rows = 100L)
head(p_agn)
```

Contrast this with the original dataset given in the previous section. The distribution of the values, features like rounding, and factor levels, etc. are **not** preserved!

By default, all of the synthetic columns generated by stubble are simulated from uniform distributions, such that every possible value has equal probability of appearing.[^1] This is equivalent to setting `method = "agnostic"` in the call to `stubblise()`.

### Control parameters

If you did want to use the same factor levels, however, you can do so, using the relevant control parameters which are available (see `?stubble_ctrl` for details).

```{r factor.levels}
set.seed(use_seed)
p_agn_2 <- stubblise(p_agn, agn_fct_lvls = list(levels(p$species)))
head(p_agn_2)
```

Some control parameters have a prefix `agn_` or `emp_`, which refers to the data generation method: *agn*ostic (that is, generated uniformly at random) or *emp*irical (that is, generated from an approximation to the empirical distribution of each variable).

Going further, control parameters can be specified for each column so as to produce more realistic looking data, even when the .[^2]

```{r realistic}
library(dplyr)

min_numeric <- function(x) if (is.numeric(x)) min(x, na.rm = TRUE) else NA_real_
max_numeric <- function(x) if (is.numeric(x)) max(x, na.rm = TRUE) else NA_real_

mins <- summarise(p, across(.fns = min_numeric))
maxs <- summarise(p, across(.fns = max_numeric))
species_lvls <- levels(p$species)
species_rows <- count(p, species)$n

set.seed(use_seed)
p_agn_3 <- purrr::map2_dfr(
  species_rows, species_lvls,
  ~ stubblise(
    p, rows = .x,
    agn_dbl_min = mins, agn_dbl_max = maxs, agn_dbl_round = 1L,
    agn_int_min = mins, agn_int_max = maxs,
    agn_fct_lvls = list(species_lvls), agn_fct_use_lvls = .y
  )
)

head(p_agn_3, 10)
```

Note this important feature of the control parameter syntax: elements of vector parameters (like `agn_dble_min`) apply to corresponding columns (first element to first column, second to second, and so on, with recycling). If the parameter for a single column is a vector (like `agn_fct_lvls`), then it should be wrapped in `list()`.

### More realistic data

Although the result of the previous section looks much more realistic, there are obvious differences. It is easy to see, for example, that the `body_mass_g` column for setosa differs from the original `penguins_ext` dataset. This is because although different species tend to have different petal widths in the original data, in the synthetic version there are no such relationships (**Figure**). 

<br />

```{r figure, fig.width=6, fig.height=3, fig.cap="**Figure 1.** (A) Original and (B) synthetic penguins data", echo=FALSE, warning=FALSE, message=FALSE}
library(ggplot2)
library(cowplot)

g1 <- ggplot(p, aes(x = species, y = body_mass_g, fill = species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")

g2 <- ggplot(p_agn_3, aes(x = species, y = body_mass_g, fill = species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")

plot_grid(g1, g2, labels = "AUTO")
```

<br />

There is no facility in stubble to automatically generate relationships between variables, because it is intended only to generate "simple" synthetic data. The motivations for this are:

- First and foremost, **data protection**, since associations and other statistics generated from real data can disclose sensitive information; and
- **computation speed**, since generating correlated data will necessarily be slower.

Note that original column names and types are revealed in stubblised datasets, and if these are sensitive, then appropriate data protection measures should also be applied to the synthetic data.

If, despite stubble's intended limitations, you do want to generate associations, it may still be possible. In the `penguins_ext` example, different control parameters for the numeric columns could be passed to `stubblise()` for each species.

## **Very** realistic data: `method = "empirical"`

The control parameters for the `"agnostic"` method may be useful when you wish to generate synethetic data that includes very limited information from the original dataset, or when there are no actual original data, just a "shell" with named and typed columns, but no rows.

Sometimes, however, you may wish to generate data in which each variable looks very much like the original. This is possible in stubble by setting `method = "empirical"`, e.g.

```{r empirical}
set.seed(use_seed)
p_emp <- stubblise(p, rows = 100L, method = "empirical")
head(p_emp)
```

<br />


[^1]: Or, as close as possible to uniformly distributions, given that all values are derived from pseudo-random number generators. The exception is character vectors, in which every string length has equal probability, and then conditional on string length `n`, every symbol (upper- and lower-case letters, numbers and selected punctuation) has equal probability of appearing in each of the `n` positions. This does not sample uniformly from all such strings of length up to `n`!

[^2]: The code here extracts minima and maxima and factor levels, finds the number of rows for each species, then calls `stubblise()` for each species (via `purrr::map2_dfr()`) to give the same number of rows per species as in the original `p`. Because the `map2_dfr()` function binds its results into a single data frame, the `s7pecies` columns need to be compatible. This is ensured by giving a `agn_fct_lvls` parameter including all 3 levels, while the `agn_fct_use_lvls` parameter includes only the level for the current species.
