---
title: "Using stubble"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using stubble}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ggplot2)
library(cowplot)
```

**stubble** helps you generate simple synthetic datasets matching the format of a supplied data frame-like object (including base R data frames, tibbles, data.tables, and lists of vectors). 

## Default operation

Because real data are often sensitive and unsuitable for sharing, stubble produces nonsense data unless you tell it not to. With default options, the function `stubblise()` (equivalently, `stubblize()`) will produce a data frame that shares only the column names and types with the source dataset.

``` {r seed, echo=FALSE}
set.seed(98723895)
```

```{r example}
library(stubble)
stubblise(iris)
```

Contrast this with the actual `iris` dataset. The distribution of the values, features like rounding, and factor levels, etc. are **not** preserved:

```{r iris}
head(iris, 10)
```

All of the synthetic columns generated by stubble are simulated from uniform distributions, such that every possible value has equal probability of appearing (or as close as possible, given that all values are derived from pseudo-random number generators).[^1]

## Control parameters

If you did want to use the same factor levels, however, you can do so, using the relevant control parameters which are available (see `?gen_col_control` for details).

```{r factor.levels}
stubblise(iris, agn_fct_lvls = list(levels(iris$Species)))
```

## More control parameters

Going further, control parameters can be specified for each column so as to produce more realistic looking data.[^2]

```{r realistic}
mins <- as.numeric(dplyr::summarise_if(iris, is.numeric, min))
maxs <- as.numeric(dplyr::summarise_if(iris, is.numeric, max))
lvls <- levels(iris$Species)
rows <- dplyr::count(iris, Species)$n

syn_iris <- purrr::map2_dfr(
  rows, lvls,
  ~ stubblise(
    iris, rows = .x,
    agn_dbl_min = mins, agn_dbl_max = maxs, agn_dbl_round = 1L,
    agn_fct_lvls = list(lvls), agn_fct_use_lvls = .y
  )
)

head(syn_iris, 10)
```

Note this important feature of the control parameter syntax: elements of vector parameters (like `mins`) apply to corresponding columns (first element to first column, second to second, and so on, with recycling). If the parameter for a single column is a vector (like `agn_fct_lvls`), then it should be wrapped in `list()`.

## Generating realistic data

Although the result of the previous section looks much more realistic, there are obvious differences. It is easy to see, for example, that the `Petal.Width` column for setosa differs from the original `iris` dataset. This is because although different species tend to have different petal widths in the original data, in the synthetic version there are no such relationships (**Figure**). 

<br />

```{r figure, fig.width=6, fig.height=3, fig.cap="**Figure 1.** Original (A) and synthetic (B) iris data", echo=FALSE}
g1 <- ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")
g2 <- ggplot(syn_iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")
plot_grid(g1, g2, labels = "AUTO")
```

<br />

There is no facility in stubble to automatically generate relationships between variables, because it is intended only to generate "simple" synthetic data. The motivations for this are:

- *computation speed*, since generating correlated data will necessarily be slower; and
- *data protection*, since associations and other statistics generated from real data can disclose sensitive information.

Note that original column names and types are revealed in stubblised datasets, and if these are sensitive, then appropriate data protection measures should also be applied to the synthetic data.

If, despite stubble's limitations, you do want to generate associations, it may still be possible. In the `iris` example, different control parameters for the numeric columns could be passed to `stubblise()` for each species. One way to do this is to convert the data from long to wide form:

```{r more_realistic_widen}
library(magrittr)

species_rows <- dim(iris)[1] / 3

iris_idd <-  iris %>% dplyr::mutate(id = rep(seq(1, species_rows),3))

iris_idd_wide <- iris_idd %>% 
  tidyr::pivot_wider(
    id_cols = id,  
    names_from = Species, 
    values_from = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
  )
```

Then the synthetic data can be generated with column-specific minima and maxima:

```{r more_realisitic_stubblise}
mins <- as.numeric(dplyr::summarise_if(iris_idd_wide, is.numeric, min))
maxs <- as.numeric(dplyr::summarise_if(iris_idd_wide, is.numeric, max))

iris_idd_wide_stub <- iris_idd_wide %>% 
  stubblise(species_rows, agn_dbl_min = mins, agn_dbl_max = maxs, agn_dbl_round = 1L)

iris_idd_wide_stub$id <- seq(1L, species_rows)
```

Finally, the data can be converted back to a long format, and re-arranged to match the structure of the original `iris` dataset:

```{r more_realistic_lengthen}
iris_stub <- iris_idd_wide_stub %>% 
  tidyr::pivot_longer(
    -id,
    names_to = c(".value", "Species"), 
    names_sep = "_"
  ) %>%
  dplyr::select(-id, -Species, Species)
```

Consequently, the synthetic data have broadly similar relationships between `Species` and the sepal and petal measurements as in the original data; for example, again, `Petal.width` is greater now in *virginica* and *versicolor* than *setosa* species (**Figure 2**). 

<br />

```{r figure_more_realistic, fig.width=6, fig.height=3, fig.cap="**Figure 2.** Original (A) and synthetic (B) iris data with associations between Species and other columns", echo=FALSE}
g1 <- ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")
g2 <- ggplot(iris_stub, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_boxplot() +
  theme_cowplot() +
  theme(legend.position = "none")
plot_grid(g1, g2, labels = "AUTO")
```

<br />


[^1]: The only exception is character vectors, in which every string length has equal probability, and then conditional on string length `n`, every symbol has equal probability of appearing in each of the `n` positions.

[^2]: The code here extracts minima and maxima and factor levels, finds the number of rows for each species, then calls `stubblise()` for each species (via `purrr::map2_dfr()`) to give the same number of rows per species as in the original `iris`. Because the `map2_dfr()` function binds its results into a single data frame, the `Species` columns need to be compatible. This is ensured by giving a `agn_fct_lvls` parameter including all 3 levels, while the `agn_fct_use_lvls` parameter includes only the level for the current species.
